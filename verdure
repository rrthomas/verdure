#!/usr/bin/env python3
#
# Â© Reuben Thomas <rrt@sc3d.org> 2020
# Released under the GPL version 3, or (at your option) any later version.

__version__ = '1'

import os
import sys
import argparse
import logging
import pathlib
import shutil
import subprocess

# Command-line arguments
parser = argparse.ArgumentParser(
    description='Run a program with a given version.',
    epilog='''
A command template is a shell script. It is run with environment variables
PROGRAM and VERSION set to the values provided on the command line.
''',
)
parser.add_argument('-V', '--version', action='version',
                    version=f'%(prog)s version {__version__} (24 Sep 2020) by Reuben Thomas <rrt@sc3d.org>')
parser.add_argument('-f', '--force', action='store_true',
                    help='install the given version even if already installed')
parser.add_argument('--install-only', action='store_true',
                    help='just install the program, do not run it')
parser.add_argument('--install-cmd', metavar='COMMAND-TEMPLATE',
                    help='how to download and install the program')
parser.add_argument('-q', '--quiet', action='store_true',
                    help='suppress the output of the install command')
parser.add_argument('-v', '--verbose', action='store_true',
                    help='show the commands being run')
parser.add_argument('program', metavar='PROGRAM',
                    help='the name of the program to run')
parser.add_argument('version', metavar='VERSION',
                    help='the desired version of the program to run')
parser.add_argument('args', metavar='...', nargs=argparse.REMAINDER,
                    help='arguments to PROGRAM')
args = parser.parse_args()

# Error messages
logging.basicConfig(format=f'{parser.prog}: %(message)s')
logger = logging.getLogger(__name__)
def warn(s): logger.warning(s)
def die(s): warn(s); sys.exit(1)

# Compute installation directory and executable name
xdg_cache_dir = os.getenv('XDG_CACHE_HOME') or os.path.expanduser('~/.cache')
install_dir = os.path.join(xdg_cache_dir, parser.prog, args.program, args.version)
program_executable = os.path.join(install_dir, args.program)
program_runner = os.path.join(install_dir, f'{args.program}-run')
program_environment = os.path.join(install_dir, f'{args.program}-env')

# Check whether we have pointless command-line arguments
if args.install_only and len(args.args) > 0:
    die(f"arguments passed to '{args.program}' but --install-only was used")

# Install program if needed
if args.force or not os.path.isfile(program_runner):
    if not args.install_cmd:
        die(f"'{args.program}' version {args.version} not found; use --install-cmd")

    try:
        if os.path.exists(install_dir):
            shutil.rmtree(install_dir)
        pathlib.Path(install_dir).mkdir(parents=True, exist_ok=True)
        install_cmd = [
            'env',
            f'--chdir={install_dir}',
            f'PROGRAM={args.program}', f'VERSION={args.version}', f'PROGRAM_ENV={program_environment}',
            'sh', '-c', args.install_cmd,
        ]
        if args.verbose:
            warn('Installing: ' + ' '.join(install_cmd))
        open(program_environment, 'a').close()
        stdout, stderr = None, None
        if args.quiet:
            stdout, stderr = subprocess.DEVNULL, subprocess.DEVNULL
        subprocess.check_call(install_cmd, stdout=stdout, stderr=stderr)
        with open(program_runner, 'w') as runner:
            print(f'''\
#!/bin/sh
. {program_environment}
{program_executable} "$@"''', file=runner)
        subprocess.check_call(['chmod', '+x', program_runner])
    except Exception as err:
        die(err)

# Run
if not args.install_only:
    if args.verbose:
        warn('Running: ' + ' '.join([program_runner] + args.args))
    os.execv(program_runner, [program_runner] + args.args)
